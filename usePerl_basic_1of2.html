<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
 
<title>Perl 바로쓰기 1/2</title>
 
<meta name="description" content="Perl 바로쓰기 1/2">    
 
  <meta name="author" content="김현승" />
 
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
 
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
 
<link rel="stylesheet" href="reveal.js/css/reveal.min.css">
  <link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
 
 
<!-- For syntax highlighting -->
  <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
 
 
<!--[if lt IE 9]>
<script src="reveal.js/lib/js/html5shiv.js"></script>
<![endif]-->
</head>
 
<body>
 
<div class="reveal">
 
<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
 
<section>
<h1>Perl 바로쓰기 1/2</h1>
<h3>김현승</h3>
<p>
<h4>2014-04-14</h4>
</p>
</section>  
 
 
<section id="강사의-신뢰성" class="slide level2">
<h1>강사의 신뢰성</h1>
<ul>
<li class="fragment roll-in">1998년 Perl 시작, 16년째 펄 짓.</li>
<li class="fragment roll-in">PerlMania(지금은 고인된...) 부시삽 역임.</li>
<li class="fragment roll-in">2005년에 코딩테스트 Perl로 보고 입사. 채점의 어려움.</li>
<li class="fragment roll-in">Perl로 안되는건 다른 언어로 하는 Cool함.</li>
<li class="fragment roll-in">Perl로 다 만들어 놓고 포팅해주는 친절함.</li>
<li class="fragment roll-in">PLEGA 라는 사내 스크립팅 동호회 회장.</li>
</ul>
</section>
<section class="slide level2">

<h3 id="perl이-쭈구리된-이유">Perl이 쭈구리된 이유</h3>
<ul>
<li class="fragment roll-in">시대적 희생번트
<ul>
<li class="fragment roll-in">C CGI -&gt; Perl CGI -&gt; PHP -&gt; Servlet -&gt; ROR, Django, Spring ...</li>
<li class="fragment roll-in">유행에 민감한 우리나라</li>
<li class="fragment roll-in">바이트코드의 부재</li>
<li class="fragment roll-in">번역서의 부재</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h3 id="여기에-우리가-모인-이유">여기에 우리가 모인 이유</h3>
<ul>
<li class="fragment roll-in">시대적 희생번트
<ul>
<li class="fragment roll-in">레거시 담당</li>
<li class="fragment roll-in">어디나 설치된 것은 Perl</li>
<li class="fragment roll-in">번역서의 부재</li>
</ul></li>
</ul>
</section>
<section id="perl-바로쓰기-12" class="slide level2">
<h1>Perl 바로쓰기 1/2</h1>
<ul>
<li class="fragment roll-in">Perl 버전의 확인</li>
<li class="fragment roll-in">Core 모듈들</li>
<li class="fragment roll-in">파이프의 사용</li>
<li class="fragment roll-in">입출력 가공하기</li>
<li class="fragment roll-in">다른 프로그램 실행하기</li>
</ul>
</section>
<section class="slide level2">

<h3 id="perl의-기초는">Perl의 기초는</h3>
<ul>
<li class="fragment roll-in"><a href="http://qntm.org/files/perl/perl_kr.html">2시간 반만에 펄 익히기</a></li>
</ul>
</section>
<section class="slide level2">

<h3 id="버전과-위치">버전과 위치</h3>
<pre class="bash"><code>$ perl -v

This is perl, v5.8.8 built for i386-linux-thread-multi

Copyright 1987-2006, Larry Wall

Perl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.

Complete documentation for Perl, including FAQ lists, should be found on
this system using &quot;man perl&quot; or &quot;perldoc perl&quot;.  If you have access to the
Internet, point your browser at http://www.perl.org/, the Perl Home Page.

$ which perl
/usr/bin/perl

$</code></pre>
</section>
<section class="slide level2">

<h3 id="core모듈-확인-방법">Core모듈 확인 방법</h3>
<ul>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/index.html">perl 5.8.8</a></li>
<li class="fragment roll-in">Core 모듈은 배포 버전에 기본적으로 들어있는 모듈들이다.</li>
<li class="fragment roll-in">Site 모듈은 직접 make로 빌드하여 설치하거나, cpan/cpanm 등을 이용하여 설치한다.
<ul>
<li class="fragment roll-in"><a href="https://metacpan.org/">MetaCPAN</a></li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h4 id="유용한-코어모듈들">유용한 코어모듈들</h4>
<ul>
<li class="fragment roll-in"><strong>C</strong>
<ul>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/Carp.html">Carp</a> : 예외를 던졌을때 Stack Trace를 볼수 있다.</li>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/CGI.html">CGI</a> : 기본적인 CGI 모듈</li>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/Cwd.html">Cwd</a> : 현재디렉토리의 경로나 특정 파일의 절대 경로등을 얻을 수 있다.</li>
</ul></li>
<li class="fragment roll-in"><strong>D</strong>
<ul>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/Data/Dumper.html">Data::Dumper</a> : 데이터를 덤프해서 볼때 유용하다.</li>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/Digest/MD5.html">Digest::MD5</a> : MD5 해시를 만들어 낸다.</li>
</ul></li>
<li class="fragment roll-in"><strong>E</strong>
<ul>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/Encode.html">Encode</a> : 문자열 인코딩을 변경시켜준다.</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<ul>
<li class="fragment roll-in"><strong>G</strong>
<ul>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/Getopt/Long.html">Getopt::Long</a> : 프로그램이 실행될 때 넣는 커맨드라인 명령들을 편리하게 정의할 수 있게 해준다.</li>
</ul></li>
<li class="fragment roll-in"><strong>I</strong>
<ul>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/IO/Select.html">IO::Select</a> : 2개 이상의 입출력을 동시에 모니터링할때 사용한다.</li>
</ul></li>
<li class="fragment roll-in"><strong>M</strong>
<ul>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/MIME/Base64.html">MIME::Base64</a> : Base64 인코딩/디코딩 모듈</li>
</ul></li>
<li class="fragment roll-in"><strong>T</strong>
<ul>
<li class="fragment roll-in"><a href="http://perldoc.perl.org/5.8.8/Term/ANSIColor.html">Term::ANSIColor</a> : 터미널에 컬러값을 출력해준다.</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h3 id="파이프">파이프</h3>
<ul>
<li class="fragment roll-in">IPC(Inter Process Communication)의 방법중 하나</li>
<li class="fragment roll-in">프로그램의 출력을 다른 프로그램의 입력으로 연결함으로써</li>
<li class="fragment roll-in">작은 여러개의 프로그램을 조합하여 출력결과를 가공하는데 사용</li>
</ul>
</section>
<section class="slide level2">

<h4 id="파이프로-스트림-받기">파이프로 스트림 받기</h4>
<ul>
<li class="fragment roll-in">파이프( <code>|</code> ) 로 데이터를 받는다는 것은 표준입력을 읽는다는 것이다.</li>
<li class="fragment roll-in">그래서 STDIN 을 읽어서 처리하면 된다.</li>
<li class="fragment roll-in"><파일핸들> 은 줄단위의 데이터가 입력되면, 포함한 문자열이 리턴된다. 단, EOF(End Of File)가 감지되면 undef를 리턴한다.</li>
</ul>
</section>
<section class="slide level2">

<p>stdin.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl
use strict;

my $line;
while( $line = &lt;STDIN&gt; ) # 줄단위의 데이터가 들어올 때까지 Block 된다.
{
    chomp($line);
    print &quot;&gt;&gt; $line\n&quot;;
}</code></pre>
</section>
<section class="slide level2">

<p>Output : 키보드 입력</p>
<pre class="bash"><code>$ perl stdin.pl
(대기중... 아래글을 입력)
HELLO
&gt;&gt; HELLO
^D
$ </code></pre>
<ul>
<li class="fragment roll-in">표준입력이 PIPE로 주어지지 않는다면, Ctrl+D를 입력하기 전까지는 루프를 무한정 돌게 된다.</li>
<li class="fragment roll-in">Ctrl+D는 EOF를 의미한다.</li>
<li class="fragment roll-in">Windows에서는 Ctrl+Z 이다.</li>
</ul>
</section>
<section class="slide level2">

<p>Output : 파이프 입력</p>
<pre class="bash"><code>$ echo &quot;hello there&quot; | perl stdin.pl
&gt;&gt; hello there
$</code></pre>
<ul>
<li class="fragment roll-in">파이프로 연결되면, 선행하는 명령이 종료될 때, EOF를 감지하게 되어 루프를 종료하게 된다.</li>
</ul>
</section>
<section class="slide level2">

<h4 id="파이프로-스트림-내보내기">파이프로 스트림 내보내기</h4>
<ul>
<li class="fragment roll-in">파이프로 스트림을 내보내는 것은 STDOUT으로 출력한다는 의미이다. 그래서 print 또는 print STDOUT 을 이용한다.</li>
<li class="fragment roll-in">STDERR을 이용해도 화면에 출력할 수 있다.</li>
<li class="fragment roll-in">보통 스크립트는 파일에 바로 쓰는 것보다는 STDOUT으로 출력하도록 만드는 것이 간편하다.</li>
</ul>
</section>
<section class="slide level2">

<p>stdout.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl
use strict;

print &quot;Hello STDOUT\n&quot;;

print STDOUT &quot;Hello STDOUT\n&quot;;

print STDERR &quot;Hello STDERR\n&quot;</code></pre>
</section>
<section class="slide level2">

<p>Output : 화면출력</p>
<pre class="bash"><code>$ perl stdout.pl
Hello STDOUT
Hello STDOUT
Hello STDERR
$ </code></pre>
<ul>
<li class="fragment roll-in">화면상에는 셋 다 출력 된다.</li>
</ul>
</section>
<section class="slide level2">

<p>Output : 출력 리디렉션 1</p>
<pre class="bash"><code>$ perl stdout.pl &gt; output.txt
Hello STDERR

$ cat output.txt
Hello STDOUT
Hello STDOUT</code></pre>
<ul>
<li class="fragment roll-in"><code>&gt;</code> 로 출력을 파일로 돌려보면 STDERR로 출력한 것만 여전히 화면으로 나온다.</li>
</ul>
</section>
<section class="slide level2">

<p>Output : 출력 리디렉션 2</p>
<pre class="bash"><code>$ perl stdout.pl 1&gt;output.txt 2&gt;error.txt

$ cat output.txt
Hello STDOUT
Hello STDOUT

$ cat error.txt
Hello STDERR</code></pre>
<ul>
<li class="fragment roll-in"><code>1&gt;</code> 은 STDOUT,</li>
<li class="fragment roll-in"><code>2&gt;</code> 은 STDERR 을 의미하고 각각 다른 파일로 보낼수 있다.</li>
</ul>
</section>
<section class="slide level2">

<p>Output : 출력 리디렉션 3</p>
<pre class="bash"><code>$ perl stdout.pl &gt; output.txt 2&gt;&amp;1 
$ cat output.txt
Hello STDOUT
Hello STDOUT
Hello STDERR
$ </code></pre>
<ul>
<li class="fragment roll-in"><code>2&gt;&amp;1</code> 과 같이 하면 STDERR 출력이 STDOUT으로 취급된다.</li>
</ul>
</section>
<section class="slide level2">

<h4 id="한줄로-코딩하기">한줄로 코딩하기</h4>
<ul>
<li class="fragment roll-in">서버 작업에서는 한번 쓰고 버리는 스크립트를 작성하는 경우가 자주 있다.</li>
<li class="fragment roll-in">파이프로 받은 값을 임시로 처리하는 경우에 자주 사용하게 된다.</li>
<li class="fragment roll-in">스크립트 파일을 만들지 않고 한줄에 스크립트를 짜보자. 이를 원-라이너(One-liner) 라고 부르기도 한다.</li>
<li class="fragment roll-in">Bash에 의해서 $var 등이 해석되지 않게 <code>'</code>(작은따옴표)로 감싸자.</li>
</ul>
</section>
<section class="slide level2">

<p>글자 출력</p>
<pre class="bash"><code>$ perl -e &#39; print &quot;Hello World\n&quot; &#39;
Hello World</code></pre>
</section>
<section class="slide level2">

<p>파이프 입력값처리</p>
<pre class="bash"><code>$ ls -l | perl -e &#39;while($line = &lt;STDIN&gt;){ print $line; }&#39;
total 8
drwxr-xr-x  3 sng2c  staff   102  4 12 22:30 stdin
drwxr-xr-x  3 sng2c  staff   102  4 12 22:30 stdout
-rw-r--r--@ 1 sng2c  staff  2840  4 12 16:07 usePerl_basic.md</code></pre>
</section>
<section class="slide level2">

<pre class="bash"><code>$ ls -l | perl -e &#39;while(&lt;&gt;){ print $_; }&#39;
total 8
drwxr-xr-x  3 sng2c  staff   102  4 12 22:30 stdin
drwxr-xr-x  3 sng2c  staff   102  4 12 22:30 stdout
-rw-r--r--@ 1 sng2c  staff  2840  4 12 16:07 usePerl_basic.md</code></pre>
<ul>
<li class="fragment roll-in">while(&lt;&gt;)은 while( $_ = <STDIN> ) 의 축약형이다.</li>
</ul>
</section>
<section class="slide level2">

<pre class="bash"><code>$ ls -l | perl -ne &#39;print $_;&#39;
total 8
drwxr-xr-x  3 sng2c  staff   102  4 12 22:30 stdin
drwxr-xr-x  3 sng2c  staff   102  4 12 22:30 stdout
-rw-r--r--@ 1 sng2c  staff  2840  4 12 16:07 usePerl_basic.md</code></pre>
<ul>
<li class="fragment roll-in">-ne 옵션을 사용하면 while(&lt;&gt;){ ... } 을 자동으로 감싸준다.</li>
</ul>
</section>
<section class="slide level2">

<h3 id="입출력결과-다듬기">입출력결과 다듬기</h3>
<ul>
<li class="fragment roll-in">가독성을 높이기 위해서 스크립팅을 통해 입력결과를 가공하여 출력해보자</li>
</ul>
</section>
<section class="slide level2">

<h4 id="특정-글자-바꾸기">특정 글자 바꾸기</h4>
<p>replace.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl
use strict;

while( my $line = &lt;STDIN&gt; ){
    chomp($line);
    $line =~ s/sng2c/내꺼/g;
    print $line . &quot;\n&quot;;
}</code></pre>
<ul>
<li class="fragment roll-in"><span class="math">$line =~ s/패턴/대체문자열/g; : `$</span>line<code>에서</code>패턴<code>을 찾아</code>대체문자열<code>로</code>모두(g)<code>`바꿔침( =~ s/// )</code>.
<ul>
<li class="fragment roll-in">패턴
<ul>
<li class="fragment roll-in">그냥 문자열 &quot;sng2c&quot;</li>
</ul></li>
<li class="fragment roll-in">대체문자열
<ul>
<li class="fragment roll-in">&quot;내꺼&quot;</li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<p>Output</p>
<pre class="bash"><code>$ ls -l .. | perl replace.pl
total 16
drwxr-xr-x  3 내꺼  staff   102  4 13 01:25 split
drwxr-xr-x  3 내꺼  staff   102  4 12 22:30 stdin
drwxr-xr-x  3 내꺼  staff   102  4 12 22:30 stdout
-rw-r--r--@ 1 내꺼  staff  4956  4 13 01:14 usePerl_basic.md
$</code></pre>
</section>
<section class="slide level2">

<h4 id="원하는-필드만-보기">원하는 필드만 보기</h4>
<ul>
<li class="fragment roll-in"><code>ps -ef</code> 나 <code>ls -l</code> 등의 출력결과가 테이블 형태인 프로그램을 실행하고 원하는 필드만 정리해야할 경우가 자주 있다.</li>
<li class="fragment roll-in">필드간에는 WhiteSpace 즉, 공백이 채워져 있으므로, 공백을 기준으로 자른다.</li>
</ul>
</section>
<section class="slide level2">

<p>split.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl
use strict;

while( my $line = &lt;STDIN&gt; ){
    chomp($line);
    my @cols = split(/\s+/, $line);

    print &quot;$cols[0] $cols[1] $cols[2]\n&quot;;
}</code></pre>
<ul>
<li class="fragment roll-in">perl 에는 $scalar, <span class="citation" data-cites="array">@array</span>, %hash 의 3가지 기본 자료형이 있다.</li>
<li class="fragment roll-in"><span class="math"><em>c</em><em>o</em><em>l</em><em>s</em>[0]</span>cols[1] <span class="math">$cols[2] ... 와 같이 @cols는 $</span>cols[인덱스] 의 형태로 사용한다.</li>
<li class="fragment roll-in">마지막 인덱스는 (<span class="citation" data-cites="cols-1">@cols-1</span>) 으로 얻을수 있다.</li>
</ul>
</section>
<section class="slide level2">

<p>마지막 인자 출력해보기</p>
<pre class="perl"><code>    my $last = $cols[ @cols-1 ];
    print &quot;$cols[0] $cols[1] $last\n&quot;; # 복잡한 연산자가 &quot;&quot; 안에 들어가게 하지 말자</code></pre>
</section>
<section class="slide level2">

<p>Output</p>
<pre class="bash"><code>$ ls -l ..
total 16
drwxr-xr-x  3 sng2c  staff   102  4 13 01:25 split
drwxr-xr-x  3 sng2c  staff   102  4 12 22:30 stdin
drwxr-xr-x  3 sng2c  staff   102  4 12 22:30 stdout
-rw-r--r--@ 1 sng2c  staff  4956  4 13 01:14 usePerl_basic.md

$ ls -l .. | perl split.pl 
total 16 
drwxr-xr-x 3 sng2c
drwxr-xr-x 3 sng2c
drwxr-xr-x 3 sng2c
-rw-r--r--@ 1 sng2c</code></pre>
</section>
<section class="slide level2">

<p>One Line</p>
<pre class="bash"><code>$ ls -l .. | perl -ane &#39;print &quot;$F[0] $F[1] $F[2]\n&quot;&#39;
total 16 
drwxr-xr-x 3 sng2c
drwxr-xr-x 3 sng2c
drwxr-xr-x 3 sng2c
-rw-r--r--@ 1 sng2c</code></pre>
<ul>
<li class="fragment roll-in">-ane 를 이용하면 각 줄을 <span class="citation" data-cites="F에">@F에</span> 공백을 기준으로 잘라서 담아둔다.</li>
</ul>
</section>
<section class="slide level2">

<h4 id="원하는-곳-색상넣기">원하는 곳 색상넣기</h4>
<ul>
<li class="fragment roll-in">Perl의 Term::ANSIColor 모듈을 이용하여 컬러풀한 출력을 만들 수 있다. 가독성을 높여 생산성을 올릴 수 있다.</li>
<li class="fragment roll-in">참고 : <a href="http://perldoc.perl.org/5.8.8/Term/ANSIColor.html">http://perldoc.perl.org/5.8.8/Term/ANSIColor.html</a></li>
</ul>
</section>
<section class="slide level2">

<h5 id="컬러출력">컬러출력</h5>
<p>color_print.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl
use strict;
use Term::ANSIColor;

print color(&#39;yellow&#39;) . &quot;노란색\n&quot; . color(&#39;reset&#39;);

print color(&#39;red&#39;) . &quot;빨간색\n&quot; . color(&#39;reset&#39;);

print color(&#39;blink blue&#39;) . &quot;파란색깜빡\n&quot; . color(&#39;reset&#39;);</code></pre>
<ul>
<li class="fragment roll-in">원하는 색을 모두 표현하고 나면, color('reset') 으로 색을 초기화하도록 해야한다.</li>
<li class="fragment roll-in">color() 의 지정값
<ul>
<li class="fragment roll-in">초기화 : clear, reset</li>
<li class="fragment roll-in">스타일 : dark, bold, underline, underscore, blink, reverse, concealed</li>
<li class="fragment roll-in">글자색 : black, red, green, yellow, blue, magenta</li>
<li class="fragment roll-in">배경색 : on_black, on_red, on_green, on_yellow, on_blue, on_magenta, on_cyan, on_white</li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<h5 id="컬러로의-치환">컬러로의 치환</h5>
<ul>
<li class="fragment roll-in">입력으로 들어온 값의 일부를 찾아서 컬러로 변경한다.</li>
</ul>
</section>
<section class="slide level2">

<p>color_replace.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl
use strict;
use Term::ANSIColor;

my $bold = color(&#39;bold green&#39;); # 미리 저장
my $reset = color(&#39;reset&#39;);

while( my $line = &lt;STDIN&gt; ){
    chomp($line);
    $line =~ s/(\d+)/$bold$1$reset/g;
    print &quot;$line\n&quot;;
}</code></pre>
<ul>
<li class="fragment roll-in"><span class="math">$line =~ s/패턴/대체문자열/g; : `$</span>line<code>에서</code>패턴<code>을 찾아</code>대체문자열<code>로</code>모두(g)<code>`바꿔침( =~ s/// )</code>.
<ul>
<li class="fragment roll-in">패턴
<ul>
<li class="fragment roll-in">(+) : 숫자의 연속, 매칭 그룹</li>
</ul></li>
<li class="fragment roll-in">대체문자열
<ul>
<li class="fragment roll-in">$bold</li>
<li class="fragment roll-in">$1 : 1번 매칭 그룹</li>
<li class="fragment roll-in">$reset</li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level2">

<p>Output</p>
<pre class="bash"><code>$ ls -l | perl color_replace.pl

... 칼라풀 출력 결과 ...
</code></pre>
</section>
<section class="slide level2">

<p>One Line</p>
<pre class="bash"><code>$ ls -l | perl -MTerm::ANSIColor -ne &#39;$bold=color(&quot;bold green&quot;);$reset=color(&quot;reset&quot;);$_ =~ s/(\d+)/$bold$1$reset/g; print $_&#39;

... 칼라풀 출력 결과 ...
</code></pre>
<h3 id="다른-명령-실행하기">다른 명령 실행하기</h3>
</section>
<section class="slide level2">

<h4 id="출력내용을-캡쳐할-필요가-없을-때">출력내용을 캡쳐할 필요가 없을 때</h4>
<p>system.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl
use strict;
system( &#39;ls -l&#39; );</code></pre>
</section>
<section class="slide level2">

<h4 id="출력내용을-캡쳐할-때">출력내용을 캡쳐할 때</h4>
<p>backtick.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl
use strict;
my $output = `ls -l`; # `(backtick) 으로 감싼다.
print $output.&quot;\n&quot;;</code></pre>
</section>
<section class="slide level2">

<h4 id="다른-프로그램을-실행하며-종료할-때">다른 프로그램을 실행하며 종료할 때</h4>
<p>exec.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl
use strict;
exec(&#39;ls -l&#39;);
die &quot;exec FAIL!!!&quot;;</code></pre>
</section>
<section class="slide level2">

<h4 id="system-과-exec-의-차이점">system 과 exec 의 차이점</h4>
<p>system_vs_exec.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl 
use strict;
print &quot;PID : $$\n&quot;;
print &quot;--system--\n&quot;;
system(&#39;ps | grep ps&#39;);
print &quot;--exec  --\n&quot;;
exec(&#39;ps | grep ps&#39;);</code></pre>
<ul>
<li class="fragment roll-in">&quot;sh -c ps | grep ps&quot; 프로세스의 PID를 현재 프로그램의 PID와 비교해 본다.</li>
</ul>
</section>
<section class="slide level2">

<h4 id="다른-명령을-실행할때">다른 명령을 실행할때</h4>
<p>io.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl 

use strict;
use IO::Pipe;

my $out = IO::Pipe-&gt;new;
$out-&gt;reader(&#39;ls -l&#39;);

while( &lt;$out&gt; ){
    print &quot;&gt;&gt; $_&quot;;
}</code></pre>
</section>
<section class="slide level2">

<h4 id="다른-명령을-복수개-실행할때">다른 명령을 복수개 실행할때</h4>
<p>io_multi.pl</p>
<pre class="perl"><code>#!/usr/bin/env perl 
use strict;
use IO::Pipe;
use IO::Select;

my $sel = IO::Select-&gt;new;

my $out1 = IO::Pipe-&gt;new;
$out1-&gt;reader(&#39;ls -l&#39;);
$sel-&gt;add($out1);

my $out2 = IO::Pipe-&gt;new;
$out2-&gt;reader(&#39;ls -l &#39;);
$sel-&gt;add($out2);

my @ready;
while( @ready = $sel-&gt;can_read() ){
    foreach my $pipe (@ready){
        my $line = &lt;$pipe&gt;;
        unless( defined($line) ){
            $sel-&gt;remove($pipe);
            next;
        }
        print &quot;&gt;&gt; $line\n&quot;;
    }
}</code></pre>
</section>
<section class="slide level2">

<h3 id="정리">정리</h3>
<ul>
<li class="fragment roll-in">perl 버전의 확인</li>
<li class="fragment roll-in">Core 모듈들</li>
<li class="fragment roll-in">파이프의 사용</li>
<li class="fragment roll-in">입출력 가공하기</li>
</ul>
</section>
<section class="slide level2">

<h3 id="q-a">Q &amp; A</h3>
</section>
<section class="slide level2">

<h3 id="감사합니다">감사합니다</h3>
</section>
</div>
 
<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.min.js"></script>
 
<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: true,
    slideNumber: true,
    fragments: true,
 
  // available themes are in /css/theme
      theme: Reveal.getQueryHash().theme || 'default', 
   
  // default/cube/page/concave/zoom/linear/fade/none
      transition: Reveal.getQueryHash().transition || 'linear',
   
  // Optional libraries used to extend on reveal.js
  dependencies: [
    { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'reveal.js/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
    { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
  });
 
</script>
 
</body>
</html>
